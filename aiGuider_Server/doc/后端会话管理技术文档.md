# AI导游系统后端会话管理技术文档

## 1. 后端会话管理原理

AI导游系统采用基于会话(Session)的管理模式，每个连接到系统的用户都会分配一个唯一的会话ID，系统通过会话ID跟踪和管理用户状态。会话管理主要通过`SessionManager`类实现，它是系统的核心组件之一。

### 1.1 会话结构

每个会话由以下组件构成：
- **会话ID**: 使用UUID生成的唯一标识符
- **创建时间**: 会话的初始化时间
- **最后活动时间**: 用户最后一次交互的时间戳
- **对话历史**: 存储用户与AI之间的所有对话内容
- **主动消息队列**: 存储AI需要主动推送给用户的消息

### 1.2 全局会话管理器

系统使用单例模式实现`SessionManager`作为全局会话管理器，负责：
- 创建和跟踪所有活跃会话
- 定期检查和清理过期会话
- 处理用户查询和分发到对应会话
- 获取会话中的待处理消息

## 2. 会话协程机制

### 2.1 AIApplication协程机制

每个会话(`AIApplication`实例)在创建时会启动一个后台协程，通过`asyncio.create_task`创建。这个协程负责：

 **主动消息生成**: 在特定时间间隔后自动生成推荐信息、提示或问候

```python
self._task = asyncio.create_task(self._generate_proactive_messages())
```

### 2.2 SessionManager协程机制

全局会话管理器(`SessionManager`)也使用协程实现自动化管理功能。在初始化时启动一个定时清理协程：

```python
# 启动定期清理任务
asyncio.create_task(self._cleanup_expired_sessions())
```

该协程的主要职责：
1. **定期清理**: 按设定的时间间隔(默认3600秒)执行一次检查
2. **资源回收**: 识别并清理过期会话，释放系统资源
3. **自动化维护**: 无需人工干预，确保系统长期稳定运行

### 2.3 协程的生命周期管理

- **创建**: 会话初始化时创建协程任务
- **运行**: 协程在后台持续运行，不阻塞主线程
- **取消**: 会话清理时通过`cleanup()`方法取消协程
- **异常处理**: 协程内部包含异常捕获机制，确保程序稳定性

## 3. 会话创建的触发机制

会话创建通过以下机制触发：

### 3.1 触发失效会话ID的查询

当系统（SessionManager）收到一个未知会话ID的查询请求时（即用户主动向Ai应用发送消息），会自动创建新会话，并在新的会话id回传给前端应用（前端应该实现"根据回传的id判断是否要更新自身的会话id"）：

```python
def process_query(self, session_id: str, query_text: str, image=None) -> Dict:
    app = self.get_session(session_id)
    if not app:
        session_id = self.create_session()
        app = self.get_session(session_id)
```

### 3.2 应用刚启动的显式创建

API可以显式调用`create_session()`方法创建新会话，场景有：
- 前端应用刚启动并连接系统时
- 用户主动重置会话时（暂无功能）


## 4. 会话销毁的触发机制

系统实现了多层次的会话销毁机制：

### 4.1 定时清理机制

通过`_cleanup_expired_sessions`协程实现，定期检查所有会话：

```python
async def _cleanup_expired_sessions(self):
    while True:
        await asyncio.sleep(self.cleanup_interval)
        # 检查并清理过期会话
```

- 默认每小时检查一次所有会话
- 超过4小时(14400秒)未活动的会话自动标记为过期
- 过期会话通过`cleanup_session`方法清理


### 4.2 服务器关闭时的清理

在app.main.py的shutdown_event中调用session_manager.cleanup_all()清理所有会话资源

## 5 未来整改计划

### 5.1 会话数据的销毁改成数据库保存

实际上会话能不能用内存来保存，需不需要使用数据库，也需要再斟酌一下。

当前实现中，会话数据直接被删除。未来计划扩展`cleanup_session`方法，增加：
- 会话数据持久化到数据库
- 会话分析与统计功能
- 会话恢复机制 
- 使用Redis等工具进行集中式会话状态管理


### 5.2 每个会话都有一个协程的问题

当前"每个会话一个协程"的设计也需要优化：

- **资源消耗过大**：大量用户同时连接时，会创建同等数量的协程，占用过多内存资源
- **调度开销增加**：过多协程会增加异步调度器负担，可能导致整体系统响应变慢
- **随机消息生成机制不符合实际需求**：基于时间的随机生成不如基于位置/场景的触发机制有实际价值
- **扩展性受限**：难以在多实例部署环境中保持一致性

计划采用以下方案优化：

1. **统一消息生成池**：
   - 用单个协程管理所有会话的主动消息队列
   - 根据用户位置、兴趣点和上下文触发消息生成
   - 减少系统资源占用，提高可扩展性

2. **事件驱动模型**：
   - 将消息生成与会话管理分离
   - 基于地理位置、用户行为和兴趣点等事件触发消息
   - 更符合AR导游场景的实际需求

3. **消息队列系统集成**：
   - 引入专业消息队列(如Kafka)处理主动消息分发
   - 支持更可靠的消息传递和系统扩展
   - 提供更好的负载均衡能力

### 5.3 会话销毁机制增强

当前系统仅依赖定时检查实现会话清理，计划增加以下机制：

- **用户主动销毁**：
  - 添加客户端应用关闭时发送销毁信号的接口
  - 实现用户手动重置会话的功能

- **基于资源的销毁**：
  - 服务器负载过高时，优先清理长时间闲置会话
  - 设置系统最大会话数限制，超出时销毁最旧/最不活跃会话
  - 添加内存压力触发的紧急会话清理机制

### 5.4 会话监控和诊断系统

为提高系统可观测性，计划实现会话管理监控系统：

- **会话生命周期监控**：
  - 记录会话创建、活动和销毁的详细日志
  - 实现会话状态的实时监控面板

- **性能指标收集**：
  - 跟踪每个会话的资源使用情况（内存占用、协程活动等）
  - 统计会话平均生命周期、活跃度和互动频率

- **告警机制**：
  - 配置会话数量异常增长的告警
  - 监控会话资源使用超阈值的情况

### 5.5 会话安全增强

提高会话管理的安全性：

- **安全会话标识符**：
  - 评估当前UUID生成机制的安全性
  - 考虑使用更安全的随机生成算法

- **会话认证增强**：
  - 添加会话活动异常检测（如IP地址突变）
